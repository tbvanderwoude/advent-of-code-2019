extern crate rand;

use std::sync::mpsc::{channel, Receiver, Sender};
use std::thread;
use std::time::Duration;

use console::Term;

use crate::async_intcode;

pub struct Camera {
    in_channel: Receiver<i64>,
    out_channel: Sender<i64>,
    term: console::Term,
    buffer: Vec<Vec<char>>,
}

impl Camera {
    fn lookup(&self, x: i32, y: i32) -> bool {
        if (y < 0 || y >= self.buffer.len() as i32)
            || (x < 0 || x >= self.buffer[y as usize].len() as i32)
            || (self.buffer[y as usize][x as usize] == '.')
        {
            return false;
        }
        return true;
    }

    fn command(&mut self) {
        let mut i = 0;

        // This could be generated by a greedy algorithm instead:
        // It could start at the beginning pattern, look for all repetitions,
        // look for non-overlapping other patterns and build one that works.
        let prog = "A,B,A,B,A,C,B,C,A,C\n";
        let sub_a = "R,4,L,10,L,10\n";
        let sub_b = "L,8,R,12,R,10,R,4\n";
        let sub_c = "L,8,L,8,R,10,R,4\n";
        self.upload_string(prog);
        self.upload_string(sub_a);
        self.upload_string(sub_b);
        //placeholder
        self.upload_string(sub_c);
        self.upload_string("n\n");

        self.buffer.push(vec![]);
        let mut stream_buffer: Vec<char> = vec![];
        loop {
            let res = self.in_channel.recv_timeout(Duration::from_millis(500));
            if res.is_ok() {
                if res.unwrap() > 255 {
                    println!("{}", res.unwrap());
                } else {
                    let info = (res.unwrap() as u8) as char;
                    if info == '\n' {
                        println!("{}", stream_buffer.iter().collect::<String>());
                        stream_buffer.clear();
                    } else {
                        stream_buffer.push(info);
                    }
                }
            } else {
                break;
            }
            if i % 10000 == 0 {}
            i += 1;
        }
    }
    fn upload_string(&self, string: &str) {
        for c in string.chars() {
            self.out_channel.send(c as i64);
        }
    }
    fn explore(&mut self) {
        let mut i = 0;
        self.buffer.push(vec![]);
        loop {
            let res = self.in_channel.recv();
            if res.is_ok() {
                let info = (res.unwrap() as u8) as char;
                if info == '\n' {
                    self.buffer.push(vec![]);
                    self.render();

                    let mut total = 0;
                    for y in 0..self.buffer.len() {
                        for x in 0..self.buffer[y].len() {
                            if self.buffer[y as usize][x as usize] != '.' {
                                let mut neighbours = 0;
                                if self.lookup(x as i32 - 1, y as i32) {
                                    neighbours += 1;
                                }
                                if self.lookup(x as i32 + 1, y as i32) {
                                    neighbours += 1;
                                }
                                if self.lookup(x as i32, y as i32 + 1) {
                                    neighbours += 1;
                                }
                                if self.lookup(x as i32, y as i32 - 1) {
                                    neighbours += 1;
                                }
                                if neighbours > 2 {
                                    total += x * y;
                                }
                            }
                        }
                    }
                    println!("Total: {}", total);
                } else {
                    let n = self.buffer.len() - 1;
                    self.buffer[n].push(info);
                }
            }
            i += 1;
        }
    }
    fn render(&self) {
        self.term.clear_screen();
        for line in &self.buffer {
            println!("{}", line.iter().collect::<String>());
        }
    }
}

pub fn view(mut program: Vec<i64>) {
    let (comp_out, main_in): (Sender<i64>, Receiver<i64>) = channel();
    let (main_out, comp_in): (Sender<i64>, Receiver<i64>) = channel();
    let mut explorer: Camera = Camera {
        in_channel: main_in,
        out_channel: main_out,
        term: Term::stdout(),
        buffer: vec![],
    };
    program[0] = 2;
    thread::spawn(move || {
        let mut iterator = 0;
        async_intcode::run_int_code_on_computer(
            &mut iterator,
            &mut program,
            comp_in,
            comp_out,
            false,
        );
    });
    explorer.command();
}
